{"ast":null,"code":"import { __assign } from 'tslib';\nimport { invariant } from 'ts-invariant';\nimport { createFragmentMap, getFragmentFromSelection } from '../../utilities/graphql/fragments.js';\nimport { getTypenameFromResult, makeReference, isField, resultKeyNameFromField } from '../../utilities/graphql/storeUtils.js';\nimport { getOperationDefinition, getDefaultValues, getFragmentDefinitions } from '../../utilities/graphql/getFromAST.js';\nimport { shouldInclude } from '../../utilities/graphql/directives.js';\nimport { cloneDeep } from '../../utilities/common/cloneDeep.js';\nimport { makeProcessedFieldsMerger } from './helpers.js';\nimport { EntityStore } from './entityStore.js';\n\nvar StoreWriter = function () {\n  function StoreWriter(config) {\n    this.policies = config.policies;\n  }\n\n  StoreWriter.prototype.writeQueryToStore = function (_a) {\n    var query = _a.query,\n        result = _a.result,\n        _b = _a.dataId,\n        dataId = _b === void 0 ? 'ROOT_QUERY' : _b,\n        _c = _a.store,\n        store = _c === void 0 ? new EntityStore.Root({\n      policies: this.policies\n    }) : _c,\n        variables = _a.variables;\n    var operationDefinition = getOperationDefinition(query);\n    store.retain(dataId);\n    var merger = makeProcessedFieldsMerger();\n    return this.writeSelectionSetToStore({\n      result: result || Object.create(null),\n      dataId: dataId,\n      selectionSet: operationDefinition.selectionSet,\n      context: {\n        store: store,\n        written: Object.create(null),\n        merge: function merge(existing, incoming) {\n          return merger.merge(existing, incoming);\n        },\n        variables: __assign(__assign({}, getDefaultValues(operationDefinition)), variables),\n        fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n        toReference: store.toReference,\n        getFieldValue: store.getFieldValue\n      }\n    });\n  };\n\n  StoreWriter.prototype.writeSelectionSetToStore = function (_a) {\n    var dataId = _a.dataId,\n        result = _a.result,\n        selectionSet = _a.selectionSet,\n        context = _a.context;\n    var policies = this.policies;\n    var store = context.store,\n        written = context.written;\n    var sets = written[dataId] || (written[dataId] = []);\n    if (sets.indexOf(selectionSet) >= 0) return store;\n    sets.push(selectionSet);\n    var typename = getTypenameFromResult(result, selectionSet, context.fragmentMap) || store.get(dataId, \"__typename\");\n    var out = Object.create(null);\n    var processed = this.processSelectionSet({\n      result: result,\n      selectionSet: selectionSet,\n      context: context,\n      typename: typename,\n      out: out\n    });\n\n    if (out.shouldApplyMerges) {\n      processed = policies.applyMerges(makeReference(dataId), processed, context);\n    }\n\n    store.merge(dataId, processed);\n    return store;\n  };\n\n  StoreWriter.prototype.processSelectionSet = function (_a) {\n    var _this = this;\n\n    var result = _a.result,\n        selectionSet = _a.selectionSet,\n        context = _a.context,\n        typename = _a.typename,\n        out = _a.out;\n    var mergedFields = Object.create(null);\n\n    if (typeof typename === \"string\") {\n      mergedFields.__typename = typename;\n    }\n\n    var policies = this.policies;\n    var workSet = new Set(selectionSet.selections);\n    workSet.forEach(function (selection) {\n      var _a;\n\n      if (!shouldInclude(selection, context.variables)) return;\n\n      if (isField(selection)) {\n        var resultFieldKey = resultKeyNameFromField(selection);\n        var value = result[resultFieldKey];\n\n        if (typeof value !== 'undefined') {\n          var storeFieldName = policies.getStoreFieldName(typename, selection, context.variables);\n\n          var incomingValue = _this.processFieldValue(value, selection, context, out);\n\n          if (policies.hasMergeFunction(typename, selection.name.value)) {\n            incomingValue = {\n              __field: selection,\n              __typename: typename,\n              __value: incomingValue\n            };\n            out.shouldApplyMerges = true;\n          }\n\n          mergedFields = context.merge(mergedFields, (_a = {}, _a[storeFieldName] = incomingValue, _a));\n        } else if (policies.usingPossibleTypes && !(selection.directives && selection.directives.some(function (_a) {\n          var name = _a.name;\n          return name && (name.value === 'defer' || name.value === 'client');\n        }))) {\n          process.env.NODE_ENV === \"production\" || invariant.warn(\"Missing field \" + resultFieldKey + \" in \" + JSON.stringify(result, null, 2).substring(0, 100));\n        }\n      } else {\n        var fragment = getFragmentFromSelection(selection, context.fragmentMap);\n\n        if (policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n    return mergedFields;\n  };\n\n  StoreWriter.prototype.processFieldValue = function (value, field, context, out) {\n    var _this = this;\n\n    if (!field.selectionSet || value === null) {\n      return process.env.NODE_ENV === 'production' ? value : cloneDeep(value);\n    }\n\n    if (Array.isArray(value)) {\n      return value.map(function (item, i) {\n        return _this.processFieldValue(item, field, context, out);\n      });\n    }\n\n    if (value) {\n      var dataId = this.policies.identify(value, field.selectionSet, context.fragmentMap);\n\n      if (typeof dataId === 'string') {\n        this.writeSelectionSetToStore({\n          dataId: dataId,\n          result: value,\n          selectionSet: field.selectionSet,\n          context: context\n        });\n        return makeReference(dataId);\n      }\n    }\n\n    return this.processSelectionSet({\n      result: value,\n      selectionSet: field.selectionSet,\n      context: context,\n      typename: getTypenameFromResult(value, field.selectionSet, context.fragmentMap),\n      out: out\n    });\n  };\n\n  return StoreWriter;\n}();\n\nexport { StoreWriter };","map":null,"metadata":{},"sourceType":"module"}