{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@apollo/client/core'), require('@apollo/client/utilities'), require('graphql-anywhere/lib/async'), require('qs')) : typeof define === 'function' && define.amd ? define(['exports', '@apollo/client/core', '@apollo/client/utilities', 'graphql-anywhere/lib/async', 'qs'], factory) : factory(global['apollo-link-rest'] = {}, global.apolloClient.core, global.apolloClient.utilities, global.graphqlAnywhere.async, global.qs);\n})(this, function (exports, core, utilities, async, qs) {\n  'use strict';\n\n  var __extends = undefined && undefined.__extends || function () {\n    var _extendStatics = function extendStatics(d, b) {\n      _extendStatics = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (d, b) {\n        d.__proto__ = b;\n      } || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n      };\n\n      return _extendStatics(d, b);\n    };\n\n    return function (d, b) {\n      _extendStatics(d, b);\n\n      function __() {\n        this.constructor = d;\n      }\n\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n  }();\n\n  var __assign = undefined && undefined.__assign || function () {\n    __assign = Object.assign || function (t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n\n      return t;\n    };\n\n    return __assign.apply(this, arguments);\n  };\n\n  var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n\n      function step(result) {\n        result.done ? resolve(result.value) : new P(function (resolve) {\n          resolve(result.value);\n        }).then(fulfilled, rejected);\n      }\n\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  };\n\n  var __generator = undefined && undefined.__generator || function (thisArg, body) {\n    var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n        f,\n        y,\n        t,\n        g;\n    return g = {\n      next: verb(0),\n      \"throw\": verb(1),\n      \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n      return this;\n    }), g;\n\n    function verb(n) {\n      return function (v) {\n        return step([n, v]);\n      };\n    }\n\n    function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n\n      while (_) try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n\n      if (op[0] & 5) throw op[1];\n      return {\n        value: op[0] ? op[1] : void 0,\n        done: true\n      };\n    }\n  };\n\n  var _this = undefined;\n\n  var popOneSetOfArrayBracketsFromTypeName = function popOneSetOfArrayBracketsFromTypeName(typename) {\n    var noSpace = typename.replace(/\\s/g, '');\n    var sansOneBracketPair = noSpace.replace(/\\[(.*)\\]/, function (str, matchStr, offset, fullStr) {\n      return ((matchStr != null && matchStr.length) > 0 ? matchStr : null) || noSpace;\n    });\n    return sansOneBracketPair;\n  };\n\n  var addTypeNameToResult = function addTypeNameToResult(result, __typename, typePatcher) {\n    if (Array.isArray(result)) {\n      var fixedTypename_1 = popOneSetOfArrayBracketsFromTypeName(__typename); // Recursion needed for multi-dimensional arrays\n\n      return result.map(function (e) {\n        return addTypeNameToResult(e, fixedTypename_1, typePatcher);\n      });\n    }\n\n    if (null == result || typeof result === 'number' || typeof result === 'boolean' || typeof result === 'string') {\n      return result;\n    }\n\n    return typePatcher(result, __typename, typePatcher);\n  };\n\n  var quickFindRestDirective = function quickFindRestDirective(field) {\n    if (field.directives && field.directives.length) {\n      return field.directives.find(function (directive) {\n        return 'rest' === directive.name.value;\n      });\n    }\n\n    return null;\n  };\n  /**\n   * The way graphql works today, it doesn't hand us the AST tree for our query, it hands us the ROOT\n   * This method searches for REST-directive-attached nodes that are named to match this query.\n   *\n   * A little bit of wasted compute, but alternative would be a patch in graphql-anywhere.\n   *\n   * @param resultKey SearchKey for REST directive-attached item matching this sub-query\n   * @param current current node in the REST-JSON-response\n   * @param mainDefinition Parsed Query Definition\n   * @param fragmentMap Map of Named Fragments\n   * @param currentSelectionSet Current selection set we're filtering by\n   */\n\n\n  function findRestDirectivesThenInsertNullsForOmittedFields(resultKey, current, // currentSelectionSet starts at root, so wait until we're inside a Field tagged with an @rest directive to activate!\n  mainDefinition, fragmentMap, currentSelectionSet) {\n    if (currentSelectionSet == null || null == current || typeof current === 'number' || typeof current === 'boolean' || typeof current === 'string') {\n      return current;\n    }\n\n    currentSelectionSet.selections.forEach(function (node) {\n      if (utilities.isInlineFragment(node)) {\n        findRestDirectivesThenInsertNullsForOmittedFields(resultKey, current, mainDefinition, fragmentMap, node.selectionSet);\n      } else if (node.kind === 'FragmentSpread') {\n        var fragment = fragmentMap[node.name.value];\n        findRestDirectivesThenInsertNullsForOmittedFields(resultKey, current, mainDefinition, fragmentMap, fragment.selectionSet);\n      } else if (utilities.isField(node)) {\n        var name_1 = utilities.resultKeyNameFromField(node);\n\n        if (name_1 === resultKey && quickFindRestDirective(node) != null) {\n          // Jackpot! We found our selectionSet!\n          insertNullsForAnyOmittedFields(current, mainDefinition, fragmentMap, node.selectionSet);\n        } else {\n          findRestDirectivesThenInsertNullsForOmittedFields(resultKey, current, mainDefinition, fragmentMap, node.selectionSet);\n        }\n      } else {\n        // This will give a TypeScript build-time error if you did something wrong or the AST changes!\n        return function (node) {\n          throw new Error('Unhandled Node Type in SelectionSetNode.selections');\n        }(node);\n      }\n    }); // Return current to have our result pass to next link in async promise chain!\n\n    return current;\n  }\n  /**\n   * Recursively walks a handed object in parallel with the Query SelectionSet,\n   *  and inserts `null` for any field that is missing from the response.\n   *\n   * This is needed because ApolloClient will throw an error automatically if it's\n   *  missing -- effectively making all of rest-link's selections implicitly non-optional.\n   *\n   * If you want to implement required fields, you need to use typePatcher to *delete*\n   *  fields when they're null and you want the query to fail instead.\n   *\n   * @param current Current object we're patching\n   * @param mainDefinition Parsed Query Definition\n   * @param fragmentMap Map of Named Fragments\n   * @param currentSelectionSet Current selection set we're filtering by\n   */\n\n\n  function insertNullsForAnyOmittedFields(current, // currentSelectionSet starts at root, so wait until we're inside a Field tagged with an @rest directive to activate!\n  mainDefinition, fragmentMap, currentSelectionSet) {\n    if (null == current || typeof current === 'number' || typeof current === 'boolean' || typeof current === 'string') {\n      return;\n    }\n\n    if (Array.isArray(current)) {\n      // If our current value is an array, process our selection set for each entry.\n      current.forEach(function (c) {\n        return insertNullsForAnyOmittedFields(c, mainDefinition, fragmentMap, currentSelectionSet);\n      });\n      return;\n    }\n\n    currentSelectionSet.selections.forEach(function (node) {\n      if (utilities.isInlineFragment(node)) {\n        insertNullsForAnyOmittedFields(current, mainDefinition, fragmentMap, node.selectionSet);\n      } else if (node.kind === 'FragmentSpread') {\n        var fragment = fragmentMap[node.name.value];\n        insertNullsForAnyOmittedFields(current, mainDefinition, fragmentMap, fragment.selectionSet);\n      } else if (utilities.isField(node)) {\n        var value = current[node.name.value];\n        if (node.name.value === '__typename') ;else if (typeof value === 'undefined') {\n          // Patch in a null where the field would have been marked as missing\n          current[node.name.value] = null;\n        } else if (value != null && typeof value === 'object' && node.selectionSet != null) {\n          insertNullsForAnyOmittedFields(value, mainDefinition, fragmentMap, node.selectionSet);\n        }\n      } else {\n        // This will give a TypeScript build-time error if you did something wrong or the AST changes!\n        return function (node) {\n          throw new Error('Unhandled Node Type in SelectionSetNode.selections');\n        }(node);\n      }\n    });\n  }\n\n  var getEndpointOptions = function getEndpointOptions(endpoints, endpoint) {\n    var result = endpoints[endpoint || DEFAULT_ENDPOINT_KEY] || endpoints[DEFAULT_ENDPOINT_KEY];\n\n    if (typeof result === 'string') {\n      return {\n        uri: result\n      };\n    }\n\n    return __assign({\n      responseTransformer: null\n    }, result);\n  };\n  /** Replaces params in the path, keyed by colons */\n\n\n  var replaceLegacyParam = function replaceLegacyParam(endpoint, name, value) {\n    if (value === undefined || name === undefined) {\n      return endpoint;\n    }\n\n    return endpoint.replace(\":\" + name, value);\n  };\n  /** Internal Tool that Parses Paths for RestLink -- This API should be considered experimental */\n\n\n  var PathBuilder =\n  /** @class */\n  function () {\n    function PathBuilder() {}\n\n    PathBuilder.replacerForPath = function (path) {\n      if (path in PathBuilder.cache) {\n        return PathBuilder.cache[path];\n      }\n\n      var queryOrigStartIndex = path.indexOf('?');\n      var pathBits = path.split(PathBuilder.argReplacement);\n      var chunkActions = [];\n      var hasBegunQuery = false;\n      pathBits.reduce(function (processedCount, bit) {\n        if (bit === '' || bit === '{}') {\n          // Empty chunk, do nothing\n          return processedCount + bit.length;\n        }\n\n        var nextIndex = processedCount + bit.length;\n\n        if (bit[0] === '{' && bit[bit.length - 1] === '}') {\n          // Replace some args!\n          var _keyPath_1 = bit.slice(1, bit.length - 1).split('.');\n\n          chunkActions.push(function (props, useQSEncoder) {\n            try {\n              var value = PathBuilderLookupValue(props, _keyPath_1);\n\n              if (!useQSEncoder || typeof value !== 'object' || value == null) {\n                return String(value);\n              } else {\n                return qs.stringify(value);\n              }\n            } catch (e) {\n              var key = [path, _keyPath_1.join('.')].join('|');\n\n              if (!(key in PathBuilder.warnTable)) {\n                console.warn('Warning: RestLink caught an error while unpacking', key, \"This tends to happen if you forgot to pass a parameter needed for creating an @rest(path, or if RestLink was configured to deeply unpack a path parameter that wasn't provided. This message will only log once per detected instance. Trouble-shooting hint: check @rest(path: and the variables provided to this query.\");\n                PathBuilder.warnTable[key] = true;\n              }\n\n              return '';\n            }\n          });\n        } else {\n          chunkActions.push(bit);\n\n          if (!hasBegunQuery && nextIndex >= queryOrigStartIndex) {\n            hasBegunQuery = true;\n            chunkActions.push(true);\n          }\n        }\n\n        return nextIndex;\n      }, 0);\n\n      var result = function result(props) {\n        var hasEnteredQuery = false;\n        var tmp = chunkActions.reduce(function (accumulator, action) {\n          if (typeof action === 'string') {\n            return accumulator + action;\n          } else if (typeof action === 'boolean') {\n            hasEnteredQuery = true;\n            return accumulator;\n          } else {\n            return accumulator + action(props, hasEnteredQuery);\n          }\n        }, '');\n        return tmp;\n      };\n\n      return PathBuilder.cache[path] = result;\n    };\n    /** For accelerating the replacement of paths that are used a lot */\n\n\n    PathBuilder.cache = {};\n    /** Table to limit the amount of nagging (due to probable API Misuse) we do to once per path per launch */\n\n    PathBuilder.warnTable = {};\n    /** Regexp that finds things that are eligible for variable replacement */\n\n    PathBuilder.argReplacement = /({[._a-zA-Z0-9]*})/;\n    return PathBuilder;\n  }();\n  /** Private Helper Function */\n\n\n  function PathBuilderLookupValue(tmp, keyPath) {\n    if (keyPath.length === 0) {\n      return tmp;\n    }\n\n    var remainingKeyPath = keyPath.slice(); // Copy before mutating\n\n    var key = remainingKeyPath.shift();\n    return PathBuilderLookupValue(tmp[key], remainingKeyPath);\n  }\n  /**\n   * Some keys should be passed through transparently without normalizing/de-normalizing\n   */\n\n\n  var noMangleKeys = ['__typename'];\n  /** Recursively descends the provided object tree and converts all the keys */\n\n  var convertObjectKeys = function convertObjectKeys(object, __converter, keypath) {\n    if (keypath === void 0) {\n      keypath = [];\n    }\n\n    var converter = null;\n\n    if (__converter.length != 2) {\n      converter = function converter(name, keypath) {\n        return __converter(name);\n      };\n    } else {\n      converter = __converter;\n    }\n\n    if (object == null || typeof object !== 'object') {\n      // Object is a scalar or null / undefined => no keys to convert!\n      return object;\n    } // FileList/File are only available in some browser contexts\n    // Notably: *not available* in react-native.\n\n\n    if (global.FileList && object instanceof FileList || global.File && object instanceof File) {\n      // Object is a FileList or File object => no keys to convert!\n      return object;\n    }\n\n    if (Array.isArray(object)) {\n      return object.map(function (o, index) {\n        return convertObjectKeys(o, converter, keypath.concat([String(index)]));\n      });\n    }\n\n    return Object.keys(object).reduce(function (acc, key) {\n      var value = object[key];\n\n      if (noMangleKeys.indexOf(key) !== -1) {\n        acc[key] = value;\n        return acc;\n      }\n\n      var nestedKeyPath = keypath.concat([key]);\n      acc[converter(key, nestedKeyPath)] = convertObjectKeys(value, converter, nestedKeyPath);\n      return acc;\n    }, {});\n  };\n\n  var noOpNameNormalizer = function noOpNameNormalizer(name) {\n    return name;\n  };\n  /**\n   * Helper that makes sure our headers are of the right type to pass to Fetch\n   */\n\n\n  var normalizeHeaders = function normalizeHeaders(headers) {\n    // Make sure that our headers object is of the right type\n    if (headers instanceof Headers) {\n      return headers;\n    } else {\n      return new Headers(headers || {});\n    }\n  };\n  /**\n   * Returns a new Headers Group that contains all the headers.\n   * - If there are duplicates, they will be in the returned header set multiple times!\n   */\n\n\n  var concatHeadersMergePolicy = function concatHeadersMergePolicy() {\n    var headerGroups = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      headerGroups[_i] = arguments[_i];\n    }\n\n    return headerGroups.reduce(function (accumulator, current) {\n      if (!current) {\n        return accumulator;\n      }\n\n      if (!current.forEach) {\n        current = normalizeHeaders(current);\n      }\n\n      current.forEach(function (value, key) {\n        accumulator.append(key, value);\n      });\n      return accumulator;\n    }, new Headers());\n  };\n  /**\n   * This merge policy deletes any matching headers from the link's default headers.\n   * - Pass headersToOverride array & a headers arg to context and this policy will automatically be selected.\n   */\n\n\n  var overrideHeadersMergePolicy = function overrideHeadersMergePolicy(linkHeaders, headersToOverride, requestHeaders) {\n    var result = new Headers();\n    linkHeaders.forEach(function (value, key) {\n      if (headersToOverride.indexOf(key) !== -1) {\n        return;\n      }\n\n      result.append(key, value);\n    });\n    return concatHeadersMergePolicy(result, requestHeaders || new Headers());\n  };\n\n  var makeOverrideHeadersMergePolicy = function makeOverrideHeadersMergePolicy(headersToOverride) {\n    return function (linkHeaders, requestHeaders) {\n      return overrideHeadersMergePolicy(linkHeaders, headersToOverride, requestHeaders);\n    };\n  };\n\n  var SUPPORTED_HTTP_VERBS = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'];\n\n  var validateRequestMethodForOperationType = function validateRequestMethodForOperationType(method, operationType) {\n    switch (operationType) {\n      case 'query':\n        if (SUPPORTED_HTTP_VERBS.indexOf(method.toUpperCase()) !== -1) {\n          return;\n        }\n\n        throw new Error(\"A \\\"query\\\" operation can only support \\\"GET\\\" requests but got \\\"\" + method + \"\\\".\");\n\n      case 'mutation':\n        if (SUPPORTED_HTTP_VERBS.indexOf(method.toUpperCase()) !== -1) {\n          return;\n        }\n\n        throw new Error('\"mutation\" operations do not support that HTTP-verb');\n\n      case 'subscription':\n        throw new Error('A \"subscription\" operation is not supported yet.');\n\n      default:\n        var _exhaustiveCheck = operationType;\n        return _exhaustiveCheck;\n    }\n  };\n  /**\n   * Utility to build & throw a JS Error from a \"failed\" REST-response\n   * @param response: HTTP Response object for this request\n   * @param result: Promise that will render the body of the response\n   * @param message: Human-facing error message\n   */\n\n\n  var rethrowServerSideError = function rethrowServerSideError(response, result, message) {\n    var error = new Error(message);\n    error.response = response;\n    error.statusCode = response.status;\n    error.result = result;\n    throw error;\n  };\n\n  var addTypeToNode = function addTypeToNode(node, typename) {\n    if (node === null || node === undefined || typeof node !== 'object') {\n      return node;\n    }\n\n    if (!Array.isArray(node)) {\n      node['__typename'] = typename;\n      return node;\n    }\n\n    return node.map(function (item) {\n      return addTypeToNode(item, typename);\n    });\n  };\n\n  var resolver = function resolver(fieldName, root, args, context, info) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var directives, isLeaf, resultKey, exportVariablesByNode, exportVariables, _copyExportVariables, aliasedNode, preAliasingNode, isATypeCall, isNotARestCall, credentials, endpoints, headers, customFetch, operationType, typePatcher, mainDefinition, fragmentDefinitions, fieldNameNormalizer, linkLevelNameDenormalizer, serializers, responseTransformer, fragmentMap, _a, path, endpoint, pathBuilder, endpointOption, neitherPathsProvided, allParams, pathWithParams, _b, method, type, bodyBuilder, bodyKey, perRequestNameDenormalizer, bodySerializer, body, overrideHeaders, maybeBody_1, serializedBody, requestParams, requestUrl, response, result, parsed, error_1, transformer, err_1;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            directives = info.directives, isLeaf = info.isLeaf, resultKey = info.resultKey;\n            exportVariablesByNode = context.exportVariablesByNode;\n            exportVariables = exportVariablesByNode.get(root) || {};\n\n            _copyExportVariables = function copyExportVariables(result) {\n              if (result instanceof Array) {\n                result.forEach(_copyExportVariables);\n              } else {\n                // export variables are stored keyed on the node they are for\n                exportVariablesByNode.set(result, __assign({}, exportVariables));\n              }\n\n              return result;\n            };\n\n            aliasedNode = (root || {})[resultKey];\n            preAliasingNode = (root || {})[fieldName];\n\n            if (root && directives && directives.export) {\n              // @export(as:) is only supported with apollo-link-rest at this time\n              // so use the preAliasingNode as we're responsible for implementing aliasing!\n              exportVariables[directives.export.as] = preAliasingNode;\n            }\n\n            isATypeCall = directives && directives.type;\n\n            if (!isLeaf && isATypeCall) {\n              // @type(name: ) is only supported inside apollo-link-rest at this time\n              // so use the preAliasingNode as we're responsible for implementing aliasing!\n              // Also: exit early, since @type(name: ) && @rest() can't both exist on the same node.\n              if (directives.rest) {\n                throw new Error('Invalid use of @type(name: ...) directive on a call that also has @rest(...)');\n              }\n\n              _copyExportVariables(preAliasingNode);\n\n              return [2\n              /*return*/\n              , addTypeToNode(preAliasingNode, directives.type.name)];\n            }\n\n            isNotARestCall = !directives || !directives.rest;\n\n            if (isNotARestCall) {\n              // This is not tagged with @rest()\n              // This might not belong to us so return the aliasNode version preferentially\n              return [2\n              /*return*/\n              , _copyExportVariables(aliasedNode || preAliasingNode)];\n            }\n\n            credentials = context.credentials, endpoints = context.endpoints, headers = context.headers, customFetch = context.customFetch, operationType = context.operationType, typePatcher = context.typePatcher, mainDefinition = context.mainDefinition, fragmentDefinitions = context.fragmentDefinitions, fieldNameNormalizer = context.fieldNameNormalizer, linkLevelNameDenormalizer = context.fieldNameDenormalizer, serializers = context.serializers, responseTransformer = context.responseTransformer;\n            fragmentMap = utilities.createFragmentMap(fragmentDefinitions);\n            _a = directives.rest, path = _a.path, endpoint = _a.endpoint, pathBuilder = _a.pathBuilder;\n            endpointOption = getEndpointOptions(endpoints, endpoint);\n            neitherPathsProvided = path == null && pathBuilder == null;\n\n            if (neitherPathsProvided) {\n              throw new Error(\"One of (\\\"path\\\" | \\\"pathBuilder\\\") must be set in the @rest() directive. This request had neither, please add one\");\n            }\n\n            if (!pathBuilder) {\n              if (!path.includes(':')) {\n                // Colons are the legacy route, and aren't uri encoded anyhow.\n                pathBuilder = PathBuilder.replacerForPath(path);\n              } else {\n                console.warn(\"Deprecated: '@rest(path:' contains a ':' colon, this format will be removed in future versions\");\n\n                pathBuilder = function pathBuilder(_a) {\n                  var args = _a.args,\n                      exportVariables = _a.exportVariables;\n\n                  var legacyArgs = __assign({}, args, exportVariables);\n\n                  var pathWithParams = Object.keys(legacyArgs).reduce(function (acc, e) {\n                    return replaceLegacyParam(acc, e, legacyArgs[e]);\n                  }, path);\n\n                  if (pathWithParams.includes(':')) {\n                    throw new Error('Missing parameters to run query, specify it in the query params or use ' + 'an export directive. (If you need to use \":\" inside a variable string' + ' make sure to encode the variables properly using `encodeURIComponent' + '`. Alternatively see documentation about using pathBuilder.)');\n                  }\n\n                  return pathWithParams;\n                };\n              }\n            }\n\n            allParams = {\n              args: args,\n              exportVariables: exportVariables,\n              context: context,\n              '@rest': directives.rest,\n              replacer: pathBuilder\n            };\n            pathWithParams = pathBuilder(allParams);\n            _b = directives.rest, method = _b.method, type = _b.type, bodyBuilder = _b.bodyBuilder, bodyKey = _b.bodyKey, perRequestNameDenormalizer = _b.fieldNameDenormalizer, bodySerializer = _b.bodySerializer;\n\n            if (!method) {\n              method = 'GET';\n            }\n\n            if (!bodyKey) {\n              bodyKey = 'input';\n            }\n\n            body = undefined;\n            overrideHeaders = undefined;\n\n            if (-1 === ['GET', 'DELETE'].indexOf(method)) {\n              // Prepare our body!\n              if (!bodyBuilder) {\n                maybeBody_1 = allParams.exportVariables[bodyKey] || allParams.args && allParams.args[bodyKey];\n\n                if (!maybeBody_1) {\n                  throw new Error(\"[GraphQL \" + method + \" \" + operationType + \" using a REST call without a body]. No `\" + bodyKey + \"` was detected. Pass bodyKey, or bodyBuilder to the @rest() directive to resolve this.\");\n                }\n\n                bodyBuilder = function bodyBuilder(argsWithExport) {\n                  return maybeBody_1;\n                };\n              }\n\n              body = convertObjectKeys(bodyBuilder(allParams), perRequestNameDenormalizer || linkLevelNameDenormalizer || noOpNameNormalizer);\n              serializedBody = void 0;\n\n              if (typeof bodySerializer === 'string') {\n                if (!serializers.hasOwnProperty(bodySerializer)) {\n                  throw new Error('\"bodySerializer\" must correspond to configured serializer. ' + (\"Please make sure to specify a serializer called \" + bodySerializer + \" in the \\\"bodySerializers\\\" property of the RestLink.\"));\n                }\n\n                serializedBody = serializers[bodySerializer](body, headers);\n              } else {\n                serializedBody = bodySerializer ? bodySerializer(body, headers) : serializers[DEFAULT_SERIALIZER_KEY](body, headers);\n              }\n\n              body = serializedBody.body;\n              overrideHeaders = new Headers(serializedBody.headers);\n            }\n\n            validateRequestMethodForOperationType(method, operationType || 'query');\n            requestParams = __assign({\n              method: method,\n              headers: overrideHeaders || headers,\n              body: body\n            }, credentials ? {\n              credentials: credentials\n            } : {});\n            requestUrl = \"\" + endpointOption.uri + pathWithParams;\n            return [4\n            /*yield*/\n            , (customFetch || fetch)(requestUrl, requestParams)];\n\n          case 1:\n            response = _c.sent();\n            context.responses.push(response);\n            if (!response.ok) return [3\n            /*break*/\n            , 2];\n\n            if (response.status === 204 || response.headers.get('Content-Length') === '0') {\n              // HTTP-204 means \"no-content\", similarly Content-Length implies the same\n              // This commonly occurs when you POST/PUT to the server, and it acknowledges\n              // success, but doesn't return your Resource.\n              result = {};\n            } else {\n              result = response;\n            }\n\n            return [3\n            /*break*/\n            , 9];\n\n          case 2:\n            if (!(response.status === 404)) return [3\n            /*break*/\n            , 3]; // In a GraphQL context a missing resource should be indicated by\n            // a null value rather than throwing a network error\n\n            result = null;\n            return [3\n            /*break*/\n            , 9];\n\n          case 3:\n            parsed = void 0;\n            _c.label = 4;\n\n          case 4:\n            _c.trys.push([4, 6,, 8]);\n\n            return [4\n            /*yield*/\n            , response.clone().json()];\n\n          case 5:\n            parsed = _c.sent();\n            return [3\n            /*break*/\n            , 8];\n\n          case 6:\n            error_1 = _c.sent();\n            return [4\n            /*yield*/\n            , response.clone().text()];\n\n          case 7:\n            // its not json\n            parsed = _c.sent();\n            return [3\n            /*break*/\n            , 8];\n\n          case 8:\n            rethrowServerSideError(response, parsed, \"Response not successful: Received status code \" + response.status);\n            _c.label = 9;\n\n          case 9:\n            transformer = endpointOption.responseTransformer || responseTransformer;\n            if (!transformer) return [3\n            /*break*/\n            , 14];\n            _c.label = 10;\n\n          case 10:\n            _c.trys.push([10, 12,, 13]);\n\n            return [4\n            /*yield*/\n            , transformer(result, type)];\n\n          case 11:\n            result = _c.sent();\n            return [3\n            /*break*/\n            , 13];\n\n          case 12:\n            err_1 = _c.sent();\n            console.warn('An error occurred in a responseTransformer:');\n            throw err_1;\n\n          case 13:\n            return [3\n            /*break*/\n            , 16];\n\n          case 14:\n            if (!(result && result.json)) return [3\n            /*break*/\n            , 16];\n            return [4\n            /*yield*/\n            , result.json()];\n\n          case 15:\n            result = _c.sent();\n            _c.label = 16;\n\n          case 16:\n            if (fieldNameNormalizer !== null) {\n              result = convertObjectKeys(result, fieldNameNormalizer);\n            }\n\n            result = findRestDirectivesThenInsertNullsForOmittedFields(resultKey, result, mainDefinition, fragmentMap, mainDefinition.selectionSet);\n            result = addTypeNameToResult(result, type, typePatcher);\n            return [2\n            /*return*/\n            , _copyExportVariables(result)];\n        }\n      });\n    });\n  };\n  /**\n   * Default key to use when the @rest directive omits the \"endpoint\" parameter.\n   */\n\n\n  var DEFAULT_ENDPOINT_KEY = '';\n  /**\n   * Default key to use when the @rest directive omits the \"bodySerializers\" parameter.\n   */\n\n  var DEFAULT_SERIALIZER_KEY = '';\n\n  var DEFAULT_JSON_SERIALIZER = function DEFAULT_JSON_SERIALIZER(data, headers) {\n    if (!headers.has('content-type')) {\n      headers.append('Content-Type', 'application/json');\n    }\n\n    return {\n      body: JSON.stringify(data),\n      headers: headers\n    };\n  };\n\n  var CONNECTION_REMOVE_CONFIG = {\n    test: function test(directive) {\n      return directive.name.value === 'rest';\n    },\n    remove: true\n  };\n  /**\n   * RestLink is an apollo-link for communicating with REST services using GraphQL on the client-side\n   */\n\n  var RestLink =\n  /** @class */\n  function (_super) {\n    __extends(RestLink, _super);\n\n    function RestLink(_a) {\n      var _b;\n\n      var uri = _a.uri,\n          endpoints = _a.endpoints,\n          headers = _a.headers,\n          fieldNameNormalizer = _a.fieldNameNormalizer,\n          fieldNameDenormalizer = _a.fieldNameDenormalizer,\n          typePatcher = _a.typePatcher,\n          customFetch = _a.customFetch,\n          credentials = _a.credentials,\n          bodySerializers = _a.bodySerializers,\n          defaultSerializer = _a.defaultSerializer,\n          responseTransformer = _a.responseTransformer;\n\n      var _this = _super.call(this) || this;\n\n      var fallback = {};\n      fallback[DEFAULT_ENDPOINT_KEY] = uri || '';\n      _this.endpoints = Object.assign({}, endpoints || fallback);\n\n      if (uri == null && endpoints == null) {\n        throw new Error('A RestLink must be initialized with either 1 uri, or a map of keyed-endpoints');\n      }\n\n      if (uri != null) {\n        var currentDefaultURI = (endpoints || {})[DEFAULT_ENDPOINT_KEY];\n\n        if (currentDefaultURI != null && currentDefaultURI != uri) {\n          throw new Error(\"RestLink was configured with a default uri that doesn't match what's passed in to the endpoints map.\");\n        }\n\n        _this.endpoints[DEFAULT_ENDPOINT_KEY] = uri;\n      }\n\n      if (_this.endpoints[DEFAULT_ENDPOINT_KEY] == null) {\n        console.warn('RestLink configured without a default URI. All @rest(…) directives must provide an endpoint key!');\n      }\n\n      if (typePatcher == null) {\n        _this.typePatcher = function (result, __typename, _2) {\n          return __assign({\n            __typename: __typename\n          }, result);\n        };\n      } else if (!Array.isArray(typePatcher) && typeof typePatcher === 'object' && Object.keys(typePatcher).map(function (key) {\n        return typePatcher[key];\n      }).reduce( // Make sure all of the values are patcher-functions\n      function (current, patcher) {\n        return current && typeof patcher === 'function';\n      }, true)) {\n        var table_1 = typePatcher;\n\n        _this.typePatcher = function (data, outerType, patchDeeper) {\n          var __typename = data.__typename || outerType;\n\n          if (Array.isArray(data)) {\n            return data.map(function (d) {\n              return patchDeeper(d, __typename, patchDeeper);\n            });\n          }\n\n          var subPatcher = table_1[__typename] || function (result) {\n            return result;\n          };\n\n          return __assign({\n            __typename: __typename\n          }, subPatcher(data, __typename, patchDeeper));\n        };\n      } else {\n        throw new Error('RestLink was configured with a typePatcher of invalid type!');\n      }\n\n      if (bodySerializers && bodySerializers.hasOwnProperty(DEFAULT_SERIALIZER_KEY)) {\n        console.warn('RestLink was configured to override the default serializer! This may result in unexpected behavior');\n      }\n\n      _this.responseTransformer = responseTransformer || null;\n      _this.fieldNameNormalizer = fieldNameNormalizer || null;\n      _this.fieldNameDenormalizer = fieldNameDenormalizer || null;\n      _this.headers = normalizeHeaders(headers);\n      _this.credentials = credentials || null;\n      _this.customFetch = customFetch;\n      _this.serializers = __assign((_b = {}, _b[DEFAULT_SERIALIZER_KEY] = defaultSerializer || DEFAULT_JSON_SERIALIZER, _b), bodySerializers || {});\n      _this.processedDocuments = new Map();\n      return _this;\n    }\n\n    RestLink.prototype.removeRestSetsFromDocument = function (query) {\n      var cached = this.processedDocuments.get(query);\n      if (cached) return cached;\n      utilities.checkDocument(query);\n      var docClone = utilities.removeDirectivesFromDocument([CONNECTION_REMOVE_CONFIG], query);\n      this.processedDocuments.set(query, docClone);\n      return docClone;\n    };\n\n    RestLink.prototype.request = function (operation, forward) {\n      var query = operation.query,\n          variables = operation.variables,\n          getContext = operation.getContext,\n          setContext = operation.setContext;\n      var context = getContext();\n      var isRestQuery = utilities.hasDirectives(['rest'], query);\n\n      if (!isRestQuery) {\n        return forward(operation);\n      }\n\n      var nonRest = this.removeRestSetsFromDocument(query); // 1. Use the user's merge policy if any\n\n      var headersMergePolicy = context.headersMergePolicy;\n\n      if (headersMergePolicy == null && Array.isArray(context.headersToOverride)) {\n        // 2.a. Override just the passed in headers, if user provided that optional array\n        headersMergePolicy = makeOverrideHeadersMergePolicy(context.headersToOverride);\n      } else if (headersMergePolicy == null) {\n        // 2.b Glue the link (default) headers to the request-context headers\n        headersMergePolicy = concatHeadersMergePolicy;\n      }\n\n      var headers = headersMergePolicy(this.headers, context.headers);\n\n      if (!headers.has('Accept')) {\n        // Since we assume a json body on successful responses set the Accept\n        // header accordingly if it is not provided by the user\n        headers.append('Accept', 'application/json');\n      }\n\n      var credentials = context.credentials || this.credentials;\n      var queryWithTypename = utilities.addTypenameToDocument(query);\n      var mainDefinition = utilities.getMainDefinition(query);\n      var fragmentDefinitions = utilities.getFragmentDefinitions(query);\n      var operationType = (mainDefinition || {}).operation || 'query';\n      var requestContext = {\n        headers: headers,\n        endpoints: this.endpoints,\n        // Provide an empty map for this request's exports to be stuffed into\n        exportVariablesByNode: new Map(),\n        credentials: credentials,\n        customFetch: this.customFetch,\n        operationType: operationType,\n        fieldNameNormalizer: this.fieldNameNormalizer,\n        fieldNameDenormalizer: this.fieldNameDenormalizer,\n        mainDefinition: mainDefinition,\n        fragmentDefinitions: fragmentDefinitions,\n        typePatcher: this.typePatcher,\n        serializers: this.serializers,\n        responses: [],\n        responseTransformer: this.responseTransformer\n      };\n      var resolverOptions = {};\n      var obs;\n\n      if (nonRest && forward) {\n        operation.query = nonRest;\n        obs = forward(operation);\n      } else obs = core.Observable.of({\n        data: {}\n      });\n\n      return obs.flatMap(function (_a) {\n        var data = _a.data,\n            errors = _a.errors;\n        return new core.Observable(function (observer) {\n          async.graphql(resolver, queryWithTypename, data, requestContext, variables, resolverOptions).then(function (data) {\n            setContext({\n              restResponses: (context.restResponses || []).concat(requestContext.responses)\n            });\n            observer.next({\n              data: data,\n              errors: errors\n            });\n            observer.complete();\n          }).catch(function (err) {\n            if (err.name === 'AbortError') return;\n\n            if (err.result && err.result.errors) {\n              observer.next(err.result);\n            }\n\n            observer.error(err);\n          });\n        });\n      });\n    };\n\n    return RestLink;\n  }(core.ApolloLink);\n\n  exports.RestLink = RestLink;\n  exports.PathBuilder = PathBuilder;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}